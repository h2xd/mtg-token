/*!
  * pinia v2.0.0-alpha.7
  * (c) 2021 Eduardo San Martin Morote
  * @license MIT
  */
import { ref, warn, getCurrentInstance, inject, computed, reactive, watch } from 'vue';

const IS_CLIENT = typeof window !== 'undefined';

/**
 * setActivePinia must be called to handle SSR at the top of functions like
 * `fetch`, `setup`, `serverPrefetch` and others
 */
let activePinia;
/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */
const setActivePinia = (pinia) => (activePinia = pinia);
/**
 * Get the currently active pinia
 */
const getActivePinia = () => {
    if ((process.env.NODE_ENV !== 'production') && !activePinia) {
        warn(`[🍍]: getActivePinia was called with no active Pinia. Did you forget to install pinia?\n\n` +
            `const pinia = createPinia()\n` +
            `app.use(pinia)\n\n` +
            `This will fail in production.`);
    }
    return activePinia;
};
/**
 * The api needs more work we must be able to use the store easily in any
 * function by calling `useStore` to get the store Instance and we also need to
 * be able to reset the store instance between applications on the server
 */
const storesMap = new WeakMap();
/**
 * Client-side application instance used for devtools
 */
let clientApp; /*#__PURE__*/
const setClientApp = (app) => (clientApp = app);
const getClientApp = () => clientApp;
const piniaSymbol = ((process.env.NODE_ENV !== 'production')
    ? Symbol('pinia')
    : Symbol());
/**
 * Creates a Pinia instance to be used by the application
 */
function createPinia() {
    // NOTE: here we could check the window object for a state and directly set it
    // if there is anything like it with Vue 3 SSR
    const state = ref({});
    let localApp;
    let _p = [];
    // plugins added before calling app.use(pinia)
    const toBeInstalled = [];
    const pinia = {
        install(app) {
            localApp = app;
            // pinia._a = app
            app.provide(piniaSymbol, pinia);
            app.config.globalProperties.$pinia = pinia;
            // TODO: write test
            // only set the app on client for devtools
            if ( IS_CLIENT) {
                setClientApp(app);
                // this allows calling useStore() outside of a component setup after
                // installing pinia's plugin
                setActivePinia(pinia);
            }
            toBeInstalled.forEach((plugin) => _p.push(plugin.bind(null, localApp)));
        },
        use(plugin) {
            if (!localApp) {
                toBeInstalled.push(plugin);
            }
            else {
                _p.push(plugin.bind(null, localApp));
            }
        },
        _p,
        state,
    };
    return pinia;
}
/**
 * Registered stores
 */
const stores = /*#__PURE__*/ new Set();
function registerStore(store) {
    stores.add(store);
}
const getRegisteredStores = () => stores;

function isPlainObject(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
o) {
    return (o &&
        typeof o === 'object' &&
        Object.prototype.toString.call(o) === '[object Object]' &&
        typeof o.toJSON !== 'function');
}

function getDevtoolsGlobalHook() {
    return getTarget().__VUE_DEVTOOLS_GLOBAL_HOOK__;
}
function getTarget() {
    // @ts-ignore
    return typeof navigator !== 'undefined'
        ? window
        : typeof global !== 'undefined'
            ? global
            : {};
}

const HOOK_SETUP = 'devtools-plugin:setup';

function setupDevtoolsPlugin(pluginDescriptor, setupFn) {
    const hook = getDevtoolsGlobalHook();
    if (hook) {
        hook.emit(HOOK_SETUP, pluginDescriptor, setupFn);
    }
    else {
        const target = getTarget();
        const list = target.__VUE_DEVTOOLS_PLUGINS__ = target.__VUE_DEVTOOLS_PLUGINS__ || [];
        list.push({
            pluginDescriptor,
            setupFn
        });
    }
}

function formatDisplay(display) {
    return {
        _custom: {
            display,
        },
    };
}
function toastMessage(message, type) {
    const piniaMessage = '🍍 ' + message;
    if (typeof __VUE_DEVTOOLS_TOAST__ === 'function') {
        __VUE_DEVTOOLS_TOAST__(piniaMessage, type);
    }
    else if (type === 'error') {
        console.error(piniaMessage);
    }
    else if (type === 'warning') {
        console.warn(piniaMessage);
    }
    else {
        console.log(piniaMessage);
    }
}
let isAlreadyInstalled;
function addDevtools(app, store) {
    registerStore(store);
    setupDevtoolsPlugin({
        id: 'pinia',
        label: 'Pinia 🍍',
        app,
    }, (api) => {
        api.on.inspectComponent((payload, ctx) => {
            if (payload.instanceData) {
                payload.instanceData.state.push({
                    type: '🍍 ' + store.$id,
                    key: 'state',
                    editable: false,
                    value: store.$state,
                });
            }
        });
        // watch(router.currentRoute, () => {
        //   // @ts-ignore
        //   api.notifyComponentUpdate()
        // })
        const mutationsLayerId = 'pinia:mutations';
        const piniaInspectorId = 'pinia';
        if (!isAlreadyInstalled) {
            api.addTimelineLayer({
                id: mutationsLayerId,
                label: `Pinia 🍍`,
                color: 0xe5df88,
            });
            api.addInspector({
                id: piniaInspectorId,
                label: 'Pinia 🍍',
                icon: 'storage',
                treeFilterPlaceholder: 'Search stores',
            });
            isAlreadyInstalled = true;
        }
        else {
            // @ts-ignore
            api.notifyComponentUpdate();
            api.sendInspectorTree(piniaInspectorId);
            api.sendInspectorState(piniaInspectorId);
        }
        store.$subscribe((mutation, state) => {
            // rootStore.state[store.id] = state
            const data = {
                store: formatDisplay(mutation.storeName),
                type: formatDisplay(mutation.type),
            };
            if (mutation.payload) {
                data.payload = mutation.payload;
            }
            // @ts-ignore
            api.notifyComponentUpdate();
            api.sendInspectorState(piniaInspectorId);
            api.addTimelineEvent({
                layerId: mutationsLayerId,
                event: {
                    time: Date.now(),
                    data,
                    // TODO: remove when fixed
                    meta: {},
                },
            });
        });
        api.on.getInspectorTree((payload) => {
            if (payload.app === app && payload.inspectorId === piniaInspectorId) {
                const stores = Array.from(getRegisteredStores());
                payload.rootNodes = (payload.filter
                    ? stores.filter((store) => store.$id.toLowerCase().includes(payload.filter.toLowerCase()))
                    : stores).map(formatStoreForInspectorTree);
            }
        });
        api.on.getInspectorState((payload) => {
            if (payload.app === app && payload.inspectorId === piniaInspectorId) {
                const stores = Array.from(getRegisteredStores());
                const store = stores.find((store) => store.$id === payload.nodeId);
                if (store) {
                    payload.state = {
                        options: formatStoreForInspectorState(store),
                    };
                }
                else {
                    toastMessage(`store "${payload.nodeId}" not found`, 'error');
                }
            }
        });
        // trigger an update so it can display new registered stores
        // @ts-ignore
        api.notifyComponentUpdate();
        toastMessage(`"${store.$id}" store installed`);
    });
}
function formatStoreForInspectorTree(store) {
    return {
        id: store.$id,
        label: store.$id,
        tags: [],
    };
}
function formatStoreForInspectorState(store) {
    const fields = [
        { editable: false, key: 'id', value: formatDisplay(store.$id) },
        { editable: true, key: 'state', value: store.$state },
    ];
    return fields;
}

function innerPatch(target, patchToApply) {
    // TODO: get all keys like symbols as well
    for (const key in patchToApply) {
        const subPatch = patchToApply[key];
        const targetValue = target[key];
        if (isPlainObject(targetValue) && isPlainObject(subPatch)) {
            target[key] = innerPatch(targetValue, subPatch);
        }
        else {
            // @ts-ignore
            target[key] = subPatch;
        }
    }
    return target;
}
/**
 * Create an object of computed properties referring to
 *
 * @param rootStateRef - pinia.state
 * @param id - unique name
 */
function computedFromState(rootStateRef, id) {
    // let asComputed = computed<T>()
    const reactiveObject = {};
    const state = rootStateRef.value[id];
    for (const key in state) {
        // @ts-ignore: the key matches
        reactiveObject[key] = computed({
            get: () => rootStateRef.value[id][key],
            set: (value) => (rootStateRef.value[id][key] = value),
        });
    }
    return reactiveObject;
}
/**
 * Creates a store with its state object. This is meant to be augmented with getters and actions
 *
 * @param id - unique identifier of the store, like a name. eg: main, cart, user
 * @param buildState - function to build the initial state
 * @param initialState - initial state applied to the store, Must be correctly typed to infer typings
 */
function initStore($id, buildState = () => ({}), initialState) {
    const _p = getActivePinia();
    _p.state.value[$id] = initialState || buildState();
    // const state: Ref<S> = toRef(_p.state.value, $id)
    let isListening = true;
    let subscriptions = [];
    function $patch(partialState) {
        isListening = false;
        innerPatch(_p.state.value[$id], partialState);
        isListening = true;
        // because we paused the watcher, we need to manually call the subscriptions
        subscriptions.forEach((callback) => {
            callback({ storeName: $id, type: '⤵️ patch', payload: partialState }, _p.state.value[$id]);
        });
    }
    function $subscribe(callback) {
        subscriptions.push(callback);
        // watch here to link the subscription to the current active instance
        // e.g. inside the setup of a component
        const stopWatcher = watch(() => _p.state.value[$id], (state) => {
            if (isListening) {
                subscriptions.forEach((callback) => {
                    callback({ storeName: $id, type: '🧩 in place', payload: {} }, state);
                });
            }
        }, {
            deep: true,
            flush: 'sync',
        });
        return () => {
            const idx = subscriptions.indexOf(callback);
            if (idx > -1) {
                subscriptions.splice(idx, 1);
                stopWatcher();
            }
        };
    }
    function $reset() {
        subscriptions = [];
        _p.state.value[$id] = buildState();
    }
    const storeWithState = {
        $id,
        _p,
        // $state is added underneath
        $patch,
        $subscribe,
        $reset,
    };
    return [
        storeWithState,
        {
            get: () => _p.state.value[$id],
            set: (newState) => {
                isListening = false;
                _p.state.value[$id] = newState;
                isListening = true;
            },
        },
    ];
}
/**
 * Creates a store bound to the lifespan of where the function is called. This
 * means creating the store inside of a component's setup will bound it to the
 * lifespan of that component while creating it outside of a component will
 * create an ever living store
 *
 * @param partialStore - store with state returned by initStore
 * @param descriptor - descriptor to setup $state property
 * @param $id - unique name of the store
 * @param getters - getters of the store
 * @param actions - actions of the store
 */
function buildStoreToUse(partialStore, descriptor, $id, getters = {}, actions = {}) {
    const _p = getActivePinia();
    const computedGetters = {};
    for (const getterName in getters) {
        computedGetters[getterName] = computed(() => {
            setActivePinia(_p);
            // eslint-disable-next-line @typescript-eslint/no-use-before-define
            return getters[getterName].call(store, store);
        });
    }
    const wrappedActions = {};
    for (const actionName in actions) {
        wrappedActions[actionName] = function () {
            setActivePinia(_p);
            // eslint-disable-next-line
            return actions[actionName].apply(store, arguments);
        };
    }
    const extensions = _p._p.reduce((extended, extender) => ({
        ...extended,
        ...extender(),
    }), {});
    const store = reactive({
        ...extensions,
        ...partialStore,
        // using this means no new properties can be added as state
        ...computedFromState(_p.state, $id),
        ...computedGetters,
        ...wrappedActions,
    });
    // use this instead of a computed with setter to be able to create it anywhere
    // without linking the computed lifespan to wherever the store is first
    // created.
    Object.defineProperty(store, '$state', descriptor);
    return store;
}
// only warn the dev once
let isDevWarned;
/**
 * Creates a `useStore` function that retrieves the store instance
 * @param options - options to define the store
 */
function defineStore(options) {
    const { id, state, getters, actions } = options;
    return function useStore(pinia) {
        // avoid injecting if `useStore` when not possible
        pinia = pinia || (getCurrentInstance() && inject(piniaSymbol));
        if (pinia)
            setActivePinia(pinia);
        // TODO: worth warning on server if no piniaKey as it can leak data
        pinia = getActivePinia();
        let stores = storesMap.get(pinia);
        if (!stores)
            storesMap.set(pinia, (stores = new Map()));
        let storeAndDescriptor = stores.get(id);
        if (!storeAndDescriptor) {
            storeAndDescriptor = initStore(id, state, pinia.state.value[id]);
            stores.set(id, storeAndDescriptor);
            const store = buildStoreToUse(storeAndDescriptor[0], storeAndDescriptor[1], id, getters, actions);
            if (IS_CLIENT &&
                true &&
                (process.env.NODE_ENV !== 'production') /*|| __FEATURE_PROD_DEVTOOLS__*/) {
                const app = getClientApp();
                if (app) {
                    addDevtools(app, store);
                }
                else if (!isDevWarned && !(process.env.NODE_ENV === 'test')) {
                    isDevWarned = true;
                    console.warn(`[🍍]: store was instantiated before calling\n` +
                        `app.use(pinia)\n` +
                        `Make sure to install pinia's plugin by using createPinia:\n` +
                        `https://github.com/posva/pinia/tree/v2#install-the-plugin\n` +
                        `It will enable devtools and overall a better developer experience.`);
                }
            }
            return store;
        }
        return buildStoreToUse(storeAndDescriptor[0], storeAndDescriptor[1], id, getters, actions);
    };
}

/**
 * {@inheritDoc defineStore}
 * @deprecated Use {@link defineStore}
 */
const createStore = ((options) => {
    console.warn('[🍍]: "createStore" has been deprecated and will be removed on the sable release, use "defineStore" instead.');
    return defineStore(options);
});

export { createPinia, createStore, defineStore, setActivePinia };
