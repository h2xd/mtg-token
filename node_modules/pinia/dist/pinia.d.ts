import { App } from 'vue';
import { Plugin as Plugin_2 } from 'vue';
import { Ref } from 'vue';

/**
 * Creates a Pinia instance to be used by the application
 */
export declare function createPinia(): Pinia;

/**
 * {@inheritDoc defineStore}
 * @deprecated Use {@link defineStore}
 */
export declare const createStore: typeof defineStore;

declare type DeepPartial<T> = {
    [K in keyof T]?: DeepPartial<T[K]>;
};

/**
 * Creates a `useStore` function that retrieves the store instance
 * @param options - options to define the store
 */
export declare function defineStore<Id extends string, S extends StateTree, G, A>(options: {
    id: Id;
    state?: () => S;
    getters?: G & ThisType<S & StoreWithGetters<G>>;
    actions?: A & ThisType<A & S & StoreWithState<Id, S> & StoreWithGetters<G>>;
}): (pinia?: Pinia | null | undefined) => Store<Id, S, G, A>;

/**
 * Every application must own its own pinia to be able to create stores
 */
export declare interface Pinia {
    install: Exclude<Plugin_2['install'], undefined>;
    /**
     * root state
     */
    state: Ref<Record<string, StateTree>>;
    /**
     * Adds a store plugin to extend every store
     *
     * @param plugin - store plugin to add
     */
    use(plugin: PiniaStorePlugin): void;
    /**
     * Installed store plugins
     *
     * @internal
     */
    _p: Array<() => Partial<PiniaCustomProperties>>;
}

/**
 * Properties that are added to every store by `pinia.use()`
 */
export declare interface PiniaCustomProperties {
}

/**
 * Plugin to extend every store
 */
export declare interface PiniaStorePlugin {
    (app: App): Partial<PiniaCustomProperties>;
}

/**
 * Sets or unsets the active pinia. Used in SSR and internally when calling
 * actions and getters
 *
 * @param pinia - Pinia instance
 */
export declare const setActivePinia: (pinia: Pinia | undefined) => Pinia | undefined;

/**
 * Generic state of a Store
 */
export declare type StateTree = Record<string | number | symbol, any>;

/**
 * Store type to build a store
 */
export declare type Store<Id extends string, S extends StateTree, G, A> = StoreWithState<Id, S> & S & StoreWithGetters<G> & StoreWithActions<A>;

/**
 * Store augmented for actions
 * @internal
 */
export declare type StoreWithActions<A> = {
    [k in keyof A]: A[k] extends (...args: infer P) => infer R ? (...args: P) => R : never;
};

/**
 * Store augmented with getters
 * @internal
 */
export declare type StoreWithGetters<G> = {
    [k in keyof G]: G[k] extends (this: infer This, store?: any) => infer R ? R : never;
};

/**
 * Base store with state and functions
 * @internal
 */
export declare interface StoreWithState<Id extends string, S extends StateTree> {
    /**
     * Unique identifier of the store
     */
    $id: Id;
    /**
     * State of the Store. Setting it will replace the whole state.
     */
    $state: S;
    /**
     * Private property defining the pinia the store is attached to.
     *
     * @internal
     */
    _p: Pinia;
    /**
     * Applies a state patch to current state. Allows passing nested values
     *
     * @param partialState - patch to apply to the state
     */
    $patch(partialState: DeepPartial<S>): void;
    /**
     * Resets the store to its initial state by removing all subscriptions and
     * building a new state object
     */
    $reset(): void;
    /**
     * Setups a callback to be called whenever the state changes.
     *
     * @param callback - callback passed to the watcher
     * @returns function that removes the watcher
     */
    $subscribe(callback: SubscriptionCallback<S>): () => void;
}

declare type SubscriptionCallback<S> = (mutation: {
    storeName: string;
    type: string;
    payload: DeepPartial<S>;
}, state: S) => void;

export { }
